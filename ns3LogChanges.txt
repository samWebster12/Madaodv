- added a new case to ipv6-l3-protocol, Send function (case of allnode multicast):
New Case (starting at line 900):
/*
if (destination.IsAllNodesMulticast)
{
    NS_LOG_LOGIC ("Ipv4L3Protocol::Send case AllNodesMulticast");
    uint32_t ifaceIndex = 0;
    for (Ipv6InterfaceList::iterator ifaceIter = m_interfaces.begin ();
        ifaceIter != m_interfaces.end (); ifaceIter++, ifaceIndex++)
    {
        Ptr<Ipv6Interface> outInterface = *ifaceIter;
        // ANY source matches any interface
        bool sendIt = source.IsAny ();
        // check if some specific address on outInterface matches
        for (uint32_t index = 0; !sendIt && index < outInterface->GetNAddresses (); index++)
        {
            if (outInterface->GetAddress (index).GetLocal () == source)
            {
                sendIt = true;
            }
        }

        if (sendIt)
        {
            // create a proxy route for this interface
            Ptr<Ipv6Route> route = Create<Ipv6Route> ();
            route->SetDestination (destination);
            route->SetGateway (Ipv6Address::GetAny ());
            route->SetSource (source);
            route->SetOutputDevice (outInterface->GetDevice ());
            Send (packet, source, destination, protocol, route);
        }
    }
    return;

}
*/

- added case for all nodes multicast in Ipv6EndPointDemux Lookup method line 232
add line: bool localAddressMatchesWildcard = endP->GetLocalAddress () == Ipv6Address::GetAny();
change if to : if (!(localAddressMatchesExact || localAddressMatchesWildCard || destAddressIsAllNodesMulticast))
change first of bottom ifs to : if ((localAddressMatchesWildCard || destAddressIsAllnodesMulticast) && ...)

//turned off hellos
changed all m_ipv6->GetAddress (m_ipv6->GetInterfaceForAddress (receiver), 0) to m_ipv6->GetAddress (m_ipv6->GetInterfaceForAddress (receiver), 1)

//files open
udp-socket-impl.cc
ipv6-l3-protocol.cc
ipv6-end-point-demux.cc 
udp-l4-protocol.cc
ipv6-interface.cc
icmpv6-l4-protocol.cc
